{
  "version": 3,
  "sources": ["../src/eases/inOut.ts", "../src/eases/back.ts", "../src/eases/mirror.ts", "../src/eases/bounce.ts", "../src/eases/linear.ts", "../src/eases/cubicBezier.ts", "../src/eases/yoyo.ts", "../src/eases/repeat.ts", "../src/parsers/common.ts", "../src/services/cachefn.ts", "../src/parsers/colors.ts", "../src/parsers/expressions.ts", "../src/eases/eases.ts", "../src/services/tick.ts", "../src/eases/power.ts", "../src/eases/sine.ts", "../src/eases/steps.ts", "../src/utils/numbers.ts", "../src/utils/playStates.ts", "../src/services/animator.ts", "../src/components/timeline.ts", "../src/eases/elastic.ts", "../src/adapters/attribute.ts", "../src/adapters/cssvar.ts", "../src/adapters/style.ts", "../src/adapters/property.ts", "../src/parsers/transforms.ts", "../src/adapters/negateTransformList.ts", "../src/adapters/mix.ts", "../src/adapters/index.ts", "../src/services/valuecache.ts", "../src/services/targets.ts", "../src/renderers/renderTween.ts", "../src/renderers/renderSubtimeline.ts", "../src/components/timeline.animate.ts", "../src/index.ts"],
  "sourcesContent": ["import { ja } from \"../types\";\n\nexport function inOut(ease: ja.Ease, type?: ja.EaseTypes) {\n  if (type === \"out\") {\n    return (o: number) => 1 - ease(1 - o);\n  }\n  if (type === \"in-out\") {\n    return (o: number) =>\n      o < 0.5 ? ease(o * 2.0) / 2.0 : 1 - ease((1 - o) * 2) / 2;\n  }\n  return ease;\n}\n", "import { ja } from \"../types\";\nimport { inOut } from \"./inOut\";\n\nconst factor = 1.70158;\n\nexport function back(type?: ja.EaseTypes) {\n  return inOut(n => n * n * ((factor + 1) * n - factor), type);\n}\n", "import { ja } from \"../types\";\n\nexport function mirror(ease: ja.Ease) {\n  return (n: number) => 1 - ease(1 - n);\n}\n", "import { inOut } from \"./inOut\";\nimport { ja } from \"../types\";\nimport { mirror } from \"./mirror\";\n\nexport function bounce(type?: ja.EaseTypes, factor?: number) {\n  // Guard if factor comes in as a string.\n  factor = +(factor || factor === 0 ? factor : 7.5625);\n  return inOut(\n    mirror(o => {\n      if (o < 0.36363636) {\n        // (-1.0/2.75) to (1.0/2.75), centered on (0.0/2.75)\n        return factor! * o * o;\n      }\n      if (o < 0.72727273) {\n        // (1.0/2.75) to (2.0/2.75), centered on (1.5/2.75)\n        return factor! * (o -= 0.545455) * o + 0.75;\n      }\n      if (o < 0.90909091) {\n        // (2.0/2.75) to (2.5/2.75), centered on (2.25/2.75)\n        return factor! * (o -= 0.818182) * o + 0.9375;\n      }\n      // (2.5/2.75) to (2.75/2.75), centered on (2.625/2.75)\n      return factor! * (o -= 0.954545) * o + 0.984375;\n    }),\n    type\n  );\n}\n", "export function linear(o: number) {\n  return o;\n}\n", "import { linear } from \"./linear\";\n\nconst MAX_ITERATIONS = 19;\n\n// calculates cubic bezier value in one dimension, assuming initial point = 0\n// and final point = 1\nconst bezier = (c1: number, c2: number, t: number) => {\n  const it = 1 - t;\n  return ((it * c1 + t * c2) * 3 * it + t * t) * t;\n};\n\nexport const cubicBezier = (\n  cx1: number,\n  cy1: number,\n  cx2: number,\n  cy2: number\n) => {\n  // Ensure converted to numbers since they might actually be strings.\n  cx1 = +cx1;\n  cy1 = +cy1;\n  cx2 = +cx2;\n  cy2 = +cy2;\n  // if control point x component is out of range 0..1, return linear ease\n  // function instead of cubic bezier ease\n  if (cx1 < 0 || cx1 > 1 || cx2 < 0 || cx2 > 1) {\n    return linear;\n  }\n\n  return (t: number) => {\n    // return linear if out of bounds\n    if (t <= 0 || t >= 1) {\n      return t;\n    }\n\n    let min = 0;\n    let max = 1;\n    let iterations = MAX_ITERATIONS;\n    let mid: number;\n    let tPos: number;\n\n    do {\n      mid = 0.5 * (min + max);\n      tPos = bezier(cx1, cx2, mid);\n      // if this curve point is close enough to the target t value,\n      // return the ease value here\n      if (Math.abs(t - tPos) < 0.0001) {\n        return bezier(cy1, cy2, mid);\n      }\n      // update bounds and try again\n      if (tPos < t) {\n        min = mid;\n      } else {\n        max = mid;\n      }\n    } while (--iterations);\n\n    // iteration limit reached, return the ease value at the current\n    // point on the curve\n    mid = 0.5 * (min + max);\n    return bezier(cy1, cy2, mid);\n  };\n};\n", "export function yoyo(times?: number) {\n  times = +(times || times === 0 ? times : 2);\n  return (o: number) => {\n    o = o * times!;\n    const floor = ~~o;\n    return floor % 2 ? 1.0 - o + floor : o - floor;\n  };\n}\n", "export function repeat(times?: number) {\n  times = +(times || times === 0 ? times : 2);\n  return (o: number) => {\n    o = o * times!;\n    return o === times ? 1 : o - ~~o;\n  };\n}\n", "export const SYNTAX_REGEX = /^\\s*[\\(\\),\\/\\s]\\s*/;\nexport const PAREN_OPEN_REGEX = /^\\(/;\nexport const PAREN_CLOSE_REGEX = /^\\)/;\nexport const HEX_REGEX = /^#[a-f\\d]{3,6}/i;\nexport const STRING_REGEX = /^[a-z][a-z\\d\\-]*/i;\nexport const NUMBER_REGEX = /^\\-?\\d*\\.?\\d+/;\nexport const UNIT_REGEX = /^\\-?\\d*\\.?\\d+[a-z%]+/i;\nexport const PATH_COMMAND_REGEX = /^[mhvlcsqt]/i;\n\nexport interface ParserContext {\n  match: string;\n  pos: number;\n  last: number;\n  state: number;\n  pattern: string;\n}\n\n/** A bitflag token for a number. */\nexport const NUMBER = 1;\n/** A bitflag token for expression delimiter. */\nexport const SYNTAX = 2;\n/** A bitflag token for a keyword. */\nexport const STRING = 4;\n/** A bitflag token for a unit. */\nexport const UNIT = NUMBER | STRING;\n/** A bitflag token for a ( */\nexport const PAREN_OPEN = 8 | SYNTAX;\n/** A bitflag token for a ) which is also considered delimiter. */\nexport const PAREN_CLOSE = 16 | SYNTAX;\n/** A bitflag token for a function, which is composed of a keyword and a (. */\nexport const FUNCTION = 32;\n\nexport function clearContext(ctx: ParserContext, value: string) {\n  ctx.match = \"\";\n  ctx.pos = ctx.last = ctx.state = 0;\n  ctx.pattern = value;\n}\n\nexport function match(ctx: ParserContext, regex: RegExp) {\n  const match = regex.exec(ctx.pattern.substring(ctx.pos));\n  if (match) {\n    ctx.match = match[0];\n    ctx.last = ctx.pos;\n    ctx.pos += ctx.match.length;\n  }\n  return match != null;\n}\n", "type CacheableFn<T> = (str: string) => T;\n\nexport function cachefn<T>(fn: CacheableFn<T>): CacheableFn<T> {\n  const cache: Record<string, T> = {};\n  const rank: string[] = [];\n  const limit = 1000;\n  return (str: string) => {\n    let cachedValue = cache[str];\n    if (cachedValue == null) {\n      // Calculate our new value.\n      cachedValue = fn(str);\n      if (rank.length >= limit) {\n        // If we have reached the limit, remove from the top.\n        delete cache[rank[0]];\n        rank.unshift();\n      }\n      // Add our new value to the rank and cache.\n      cache[str] = cachedValue;\n      rank.push(str);\n    } else {\n      // Every time we see the value move it higher up the ranking.\n      const rankIndex = rank.indexOf(str);\n      if (rankIndex === 0) {\n        rank.splice(rankIndex, 1);\n        rank.push(str);\n      }\n    }\n    return cachedValue;\n  };\n}\n", "import { cachefn } from '../services/cachefn';\n\nfunction hexToRgb(hex: string) {\n  // Parse 3 or 6 hex to an integer using 16 base.\n  const h = parseInt(\n    hex.length === 3\n      ? hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2]\n      : hex,\n    16\n  );\n  const r = (h >> 16) & 0xff;\n  const g = (h >> 8) & 0xff;\n  const b = h & 0xff;\n\n  return `rgba(${r},${g},${b},1)`;\n}\nconst cachedHexToRgb = cachefn(hexToRgb);\nexport { cachedHexToRgb as hexToRgb };\n", "import {\n  ParserContext,\n  match,\n  FUNCTION,\n  STRING,\n  UNIT,\n  NUMBER,\n  PAREN_CLOSE,\n  PAREN_CLOSE_REGEX,\n  PAREN_OPEN_REGEX,\n  PAREN_OPEN,\n  SYNTAX_REGEX,\n  SYNTAX\n} from \"./common\";\n\nimport {\n  PATH_COMMAND_REGEX,\n  STRING_REGEX,\n  UNIT_REGEX,\n  NUMBER_REGEX,\n  HEX_REGEX\n} from \"./common\";\n\nimport { hexToRgb } from \"./colors\";\n\nexport interface MixerParserContext extends ParserContext {\n  isPath: boolean;\n}\n\nexport function nextToken(ctx: MixerParserContext): number | undefined {\n  if (match(ctx, PAREN_CLOSE_REGEX)) {\n    return PAREN_CLOSE;\n  }\n  if (match(ctx, PAREN_OPEN_REGEX)) {\n    return PAREN_OPEN;\n  }\n  if (match(ctx, SYNTAX_REGEX)) {\n    return SYNTAX;\n  }\n  if (\n    (ctx.isPath && match(ctx, PATH_COMMAND_REGEX)) ||\n    match(ctx, STRING_REGEX)\n  ) {\n    const isFunction =\n      !ctx.isPath &&\n      ctx.pos < ctx.pattern.length - 1 &&\n      ctx.pattern[ctx.pos] === \"(\";\n\n    if (!isFunction) {\n      return STRING;\n    }\n    if (ctx.match.toLowerCase() === \"rgb\") {\n      const searchString = ctx.pattern.substring(ctx.pos);\n      const endOfString = searchString.indexOf(\")\");\n      const terms = searchString.substring(1, endOfString);\n\n      ctx.pattern =\n        ctx.pattern.substring(0, ctx.pos + 1 + terms.length) +\n        \",1\" +\n        ctx.pattern.substring(ctx.pos + 1 + terms.length);\n      ctx.match = \"rgba\";\n    }\n    return FUNCTION;\n  }\n  if (!ctx.isPath && match(ctx, UNIT_REGEX)) {\n    return UNIT;\n  }\n  if (match(ctx, NUMBER_REGEX)) {\n    return NUMBER;\n  }\n  if (match(ctx, HEX_REGEX)) {\n    // If the value was hex, replace it with RGB in the string and parse that.\n    const hexValue = ctx.pattern.substring(ctx.last + 1, ctx.pos);\n    ctx.pattern =\n      ctx.pattern.substring(0, ctx.last) +\n      hexToRgb(hexValue) +\n      ctx.pattern.substring(ctx.pos);\n\n    // Reset the position and chain another call to nextToken.\n    ctx.pos = ctx.last;\n    return nextToken(ctx);\n  }\n}\n", "import { ja } from '../types';\nimport {\n  clearContext,\n  PAREN_CLOSE,\n  NUMBER,\n  STRING,\n  FUNCTION,\n} from '../parsers/common';\nimport { nextToken, MixerParserContext } from '../parsers/expressions';\nimport { linear } from './linear';\nimport { cachefn } from '../services/cachefn';\n\nconst eases = {} as Record<string, ja.EaseFactory>;\nconst easeCtx = {} as MixerParserContext;\n\n/**\n *\n * @param easeString\n */\nfunction getEase(easeString: string): ja.Ease {\n  clearContext(easeCtx, easeString);\n\n  let token: number | undefined;\n  let fn = linear;\n  let waitingForTerms = false;\n  let fnName: string | undefined;\n  const terms: string[] = [];\n\n  while (true) {\n    token = nextToken(easeCtx);\n    if (!token) {\n      fn = composeEase(fn, fnName, terms);\n      break;\n    }\n\n    if (token === PAREN_CLOSE) {\n      fn = composeEase(fn, fnName, terms);\n      fnName = undefined;\n      waitingForTerms = false;\n      terms.length = 0;\n    } else if (\n      waitingForTerms &&\n      ((token & NUMBER) !== 0 || (token & STRING) !== 0)\n    ) {\n      terms.push(easeCtx.match);\n    } else if (token === STRING) {\n      fn = composeEase(fn, easeCtx.match);\n    } else if (token === FUNCTION) {\n      fnName = easeCtx.match;\n      waitingForTerms = true;\n    }\n  }\n\n  return fn;\n}\n\n/**\n * Combines the provided function with a new function from the factory.\n * @param fn\n * @param factoryName\n * @param args\n */\nfunction composeEase(\n  fn: ja.Ease,\n  factoryName: string | undefined,\n  args?: string[]\n): ja.Ease {\n  if (!factoryName) {\n    return fn;\n  }\n  const easeFactory = eases[factoryName];\n  if (!easeFactory) {\n    return fn;\n  }\n  const outerFn = easeFactory.apply(0, args);\n  return o => outerFn(fn(o));\n}\n\nconst cachedGetEases = cachefn(getEase);\nexport { eases, cachedGetEases as getEase };\n", "const tasks: Array<(tick: number) => boolean> = [];\n\nlet promise: Promise<void> | 0;\nlet done: Function | 0;\nlet taskId: number;\n\n// let updateFrame = function (x) {\n//   return 0;\n// };\n// if (typeof requestAnimationFrame === 'function') {\n//   updateFrame = requestAnimationFrame;\n// }\n\nexport function nextAnimationFrame() {\n  //   if (!promise) {\n  //     // If we haven't used a promise, this frame, create one.\n  //     promise = new Promise((resolve) => {\n  //       done = resolve;\n  //     });\n  //   }\n  //if (!taskId) {\n  // For consistency, simply asking for the nextAnimationFrame schedules\n  // a tick if one isn't already scheduled.\n  //taskId =\n  updateAll();\n  // }\n  //return promise;\n}\n\nexport function tick(task: (tick: number) => boolean) {\n  if (tasks.indexOf(task) === -1) {\n    // If this task isn't already in the list, add it.\n    tasks.push(task);\n  }\n  //if (!taskId) {\n  // If a tick isn't scheduled, schedule it.\n  //taskId =\n  //updateAll();\n  //}\n}\n\nfunction updateAll() {\n  // Grab the current time so we can consistently provide a frame time to all\n  // animations if they need a time.\n  const tick = performance.now();\n  for (let i = 0; i < tasks.length; i++) {\n    // Call the update function. Functions that return truthy stay in queue.\n    const stayInQueue = tasks[i](tick);\n    if (!stayInQueue) {\n      // Remove update functions that returned falsey values.\n      tasks.splice(i, 1);\n      i--;\n    }\n  }\n\n  // If there are any tasks in queue, schedule next frame.\n  //taskId = tasks.length ? updateFrame(updateAll) : 0;\n\n  //   if (done) {\n  //     // If nextAnimationFrame() was called, resolve the promise to notify\n  //     // all interested parties. We have to store the done call in a local\n  //     // variable in case the code executed by then wants to reschedule another\n  //     // event. In that case, we need a new promise, so we have to store it,\n  //     // unassign it, and then resolve it.\n  //     const done2 = done;\n  //     done = 0;\n  //     promise = 0;\n  //     done2();\n  //   }\n}\n", "import { inOut } from \"./inOut\";\nimport { ja } from \"../types\";\n\nexport function power(type?: ja.EaseTypes, c?: number) {\n  // Ensure it is actually a number.\n  c = +(c || c === 0 ? c : 2);\n  return inOut((o: number) => Math.pow(o, c!), type);\n}\n", "import { ja } from \"../types\";\nimport { inOut } from \"./inOut\";\n\nexport function sine(type?: ja.EaseTypes) {\n  return inOut((o: number) => -Math.cos((o * Math.PI) / 2) + 1, type);\n}\n", "import { ja } from \"../types\";\n\nexport function steps(count: number, type?: string): ja.Ease {\n  const fn = type === \"end\" ? Math.floor : Math.ceil;\n  return (x: number) => {\n    const n = fn(x * +count) / +count;\n    return n < 0 ? 0 : n > 1 ? 1 : n;\n  };\n}\n", "/**\n * A helper for numeric sort. The default JavaScript sort is alphanumeric,\n * which would sort 1,9,10 to 1,10,9.\n * @param a the first term to compare.\n * @param b the second term to compare.\n */\nexport function byNumber(a: number, b: number) {\n  return a - b;\n}\n\n/**\n * Returns the min if the value is less than, the max if the value is greater\n * than, or the value if in between the min and max.\n * @param value The value to clamp.\n * @param min The minimum value to return.\n * @param max The maximum value to return.\n */\nexport function clamp(value: number, min: number, max: number) {\n  return Math.min(Math.max(value, min), max);\n}\n\n/**\n * Finds the index before the provided value in the list of numbers.\n * @param list The list to search.\n * @param value The value to reference.\n */\nexport function findUpperIndex(list: number[], value: number) {\n  let i = 0;\n  while (i < list.length) {\n    if (list[i] >= value) {\n      break;\n    }\n    i++;\n  }\n  return i;\n}\n\n/**\n * Returns true if the string or nunmber is numeric.\n * @param obj to test for numbers\n */\nexport function isNumeric(obj: number | string): boolean {\n  return typeof obj === 'number' || isFinite(+obj);\n}\n\n/**\n * Coerces a number string into a number;\n * @param str the string to coerce.\n */\nexport function toNumber(str: string) {\n  return +str;\n}\n", "export const IDLE = 'idle',\n  PAUSED = 'paused',\n  RUNNING = 'running',\n  FINISH = 'finish',\n  CANCEL = 'cancel';\n", "import { clamp } from '../utils/numbers';\nimport { ja } from '../types';\nimport { tick } from './tick';\nimport { IDLE, CANCEL, FINISH, PAUSED, RUNNING } from '../utils/playStates';\n\nconst FRAME_SIZE = 1000 / 60;\n\nconst queue: ja.TimelineConfig[] = [];\nlet lastTime: number;\n\nexport const renderers: Array<\n  (config: ja.TimelineConfig, operations: Array<() => void>) => void\n> = [];\n\n/**\n * Enqueues the timeline to be updated and rendered.\n * @param configurator\n */\nexport function queueTransition<T extends ja.TimelineConfig>(\n  configurator: T\n): T {\n  if (!queue.length) {\n    lastTime = performance.now();\n    tick(processTimelines);\n  }\n  if (queue.indexOf(configurator) === -1) {\n    queue.push(configurator);\n  }\n  return configurator;\n}\n\n/**\n * Updates all the timelines.\n * @param time\n */\nfunction processTimelines(time: number) {\n  // Determine the delta, clamp between 0ms and 34ms (0 frames and 2 frames).\n  const delta = clamp(time - lastTime, 0, FRAME_SIZE * 2);\n  lastTime = time;\n  // Get a list of all configs, this should match by index, the queue.\n  const configs = queue.slice();\n  // Detect automatic playState changes\n  for (const config of configs) {\n    detectPlayStateChanges(config);\n  }\n  // Update timing and fix inconsistencies.\n  for (const config of configs) {\n    updateTiming(delta, config);\n  }\n  // Update the transient playStates.\n  for (const config of configs) {\n    if (config.playState === CANCEL) {\n      config.playState = IDLE;\n    } else if (config.playState === FINISH) {\n      config.playState = PAUSED;\n    }\n  }\n  // Queue up all events.\n  const listenersToCall: ja.AnimationEventListener[] = [];\n  for (const config of configs) {\n    for (const event of config.events) {\n      if (config.listeners) {\n        const listeners = config.listeners[event];\n        if (listeners && listeners.length) {\n          Array.prototype.push.apply(listenersToCall, listeners);\n        }\n      }\n    }\n    // Remove configuration events.\n    config.events.length = 0;\n  }\n  // Render changes to the targets.\n  const operations: Array<() => void> = [];\n  for (const config of configs) {\n    for (const renderer of renderers) {\n      renderer(config, operations);\n    }\n  }\n  // // Write configurations back to their configurators.\n  // for (let i = 0; i < queue.length; i++) {\n  //   queue[i].configure(configs[i]);\n  // }\n  // Remove items from the queue if they no longer need to be updated.\n  for (let i = queue.length - 1; i > -1; i--) {\n    if (configs[i].playState !== RUNNING) {\n      queue.splice(i, 1);\n    }\n  }\n  // Call all render operations.\n  for (const operation of operations) {\n    operation();\n  }\n  // Call all listener callbacks.\n  for (const listener of listenersToCall) {\n    listener(time);\n  }\n  // Continue on the next loop if any configurators remain.\n  return !!queue.length;\n}\n\nfunction detectPlayStateChanges(config: ja.TimelineConfig) {\n  if (config.playState === RUNNING) {\n    const isBackwards = config.playbackRate < 0;\n    const activeDuration = config.duration * config.iterations;\n    // If it is off by one, clamp it.\n    const isFinished =\n      (isBackwards && config.currentTime <= 1) ||\n      (!isBackwards && config.currentTime >= activeDuration - 1);\n\n    if (isFinished) {\n      config.playState = FINISH;\n      config.events.push(FINISH);\n    }\n  }\n}\n\n/**\n * Updates the configuration with the amount of time that has elapsed since the\n * last update.\n * @param delta The amount of milliseconds since the last update.\n * @param config The configuration to update.\n */\nfunction updateTiming(delta: number, config: ja.TimelineConfig) {\n  // Make sure iterations is at least 1 and below Infinity.\n  const SECONDS_IN_A_DAY = 86400;\n  config.iterations = clamp(config.iterations, 1, SECONDS_IN_A_DAY * 7);\n\n  // Figure out the active duration.\n  const activeDuration = config.duration * config.iterations;\n\n  if (config.playState === CANCEL) {\n    // Reset the timeline.\n    config.currentTime = 0;\n    config.playbackRate = 1;\n  } else if (config.playState === FINISH) {\n    // Finish at 0 or the duration based on the playbackRate.\n    config.currentTime = config.playbackRate < 0 ? 0 : activeDuration;\n  } else {\n    if (config.playState === RUNNING) {\n      // Find the current time and clamp it between 0 and the active duration.\n      config.currentTime += delta * config.playbackRate;\n    }\n  }\n\n  // Ensure current time is not out of bounds.\n  config.currentTime = clamp(config.currentTime, 0, activeDuration);\n}\n", "import { ja } from '../types';\nimport { queueTransition } from '../services/animator';\nimport { FINISH, RUNNING, CANCEL, PAUSED } from '../utils/playStates';\n\nlet autoNumber = 0;\n\nexport class Timeline {\n  /**\n   * A unique identifier for the timeline.\n   * @public\n   */\n  id: string;\n\n  /**\n   * True if the timeline should alternate.\n   * @public\n   */\n  alternate: boolean;\n\n  /**\n   * The current time of the timeline. When using multiple iterations, this\n   * represents the actual time, not the time of the iteration.\n   * @public\n   */\n  currentTime: number;\n\n  /**\n   * The duration of one iteration of the Animation.\n   * @public\n   */\n  get duration() {\n    let duration = 0;\n    // Walk through all keyframes and determine the longest duration.\n    // tslint:disable-next-line:forin\n    for (const targetName in this.keyframes) {\n      const target = this.keyframes[targetName];\n      // tslint:disable-next-line:forin\n      for (const propName in target) {\n        for (const time in target[propName]) {\n          if (duration < +time) {\n            duration = +time;\n          }\n        }\n      }\n    }\n    return duration;\n  }\n\n  /**\n   * The queued up events to be processed by the animation renderer.\n   * @public\n   */\n  events: string[];\n\n  /**\n   * The number of iterations this Animation should play.\n   * @public\n   */\n  iterations: number;\n\n  /**\n   * The keyframes that make up the animation.\n   * @public\n   */\n  keyframes: Record<string, ja.TargetKeyframes>;\n\n  /**\n   * The labels present in the animation. This is a dictionary of named times\n   * that can be used to configure or seek in the Animation.\n   * @public\n   */\n  labels: Record<string, number>;\n\n  /**\n   * The event listeners in the animation.\n   * @public\n   */\n  listeners: Record<string, ja.AnimationEventListener[]>;\n\n  /**\n   * The current playState.  This can be cancel, idle, running, or paused.\n   * @publi\n   */\n  playState: ja.PlayState;\n\n  /**\n   * The current playbackRate.  1 is forwards, -1 is in reverse.  Use decimals\n   * to perform slowmotion.\n   * @public\n   */\n  playbackRate: number;\n\n  constructor(options?: Partial<ja.TimelineConfig>) {\n    const self = this;\n    // Ensure new in case js user forgets new or chooses to rebel against new :)\n    if (!(self instanceof Timeline)) {\n      return new Timeline(options);\n    }\n    self.id = '_' + ++autoNumber;\n    self.alternate = false;\n    self.currentTime = 0;\n    self.events = [];\n    self.iterations = 1;\n    self.keyframes = {};\n    self.labels = {};\n    self.listeners = {} as Record<\n      ja.AnimationEvent,\n      ja.AnimationEventListener[]\n    >;\n    self.playState = RUNNING;\n    self.playbackRate = 1;\n\n    if (options) {\n      self.configure(options);\n    }\n    if (!self.id.indexOf('_')) {\n      // If starts with _, it does not need to be registered globally.\n    }\n  }\n\n  /**\n   * Cancels the animation. The currentTime is set to 0 and the playState is set\n   * to 'idle'.\n   * @public\n   */\n  cancel(): this {\n    this.playState = CANCEL;\n    this.events.push(CANCEL);\n    return queueTransition(this);\n  }\n\n  /**\n   * Restores the state. This method can also be used to declaratively configure\n   * the animation instead of using animate, set, etc.\n   * @param json The state to restore.\n   * @public\n   */\n  configure(json: Partial<ja.TimelineConfig>) {\n    for (const k in json) {\n      if (typeof this[k] !== 'function' && k !== 'duration') {\n        this[k] = json[k];\n      }\n    }\n    // Configure could result in rendering changes.\n    return queueTransition(this);\n  }\n\n  /**\n   * Finish the animation. If the playbackRate is negative (in reverse), finish\n   * changes the currentTime to 0, otherwise it changes the currentTime to the\n   * activeDuration.\n   * @public\n   */\n  finish(): this {\n    this.playState = FINISH;\n    this.events.push(FINISH);\n    return queueTransition(this);\n  }\n\n  /**\n   * Gets the internal state of the Animation. This can be used to save and\n   * restore the value of the timeline.\n   * @public\n   */\n  getConfig(): ja.TimelineConfig {\n    const memento = {} as ja.TimelineConfig;\n    for (const key in this) {\n      if (key[key.length - 1] !== '_') {\n        const val = this[key];\n        if (typeof val !== 'function') {\n          memento[key as string] = val;\n        }\n      }\n    }\n    return memento;\n  }\n\n  /**\n   * Get (and possibly) create the event group for listeners.\n   * @param ev The event group to geja.\n   * @private\n   */\n  private getEventGroup_(ev: ja.AnimationEvent) {\n    let eventGroup = this.listeners[ev];\n    if (!eventGroup) {\n      eventGroup = this.listeners[ev] = [];\n    }\n    return eventGroup;\n  }\n\n  /**\n   * Gets the position by resolving a label or just returning the number if it\n   * was already a number\n   * @param pos The position to insert the next animation object.\n   * @protected\n   */\n  protected getPosition_(pos?: string | number): number {\n    // Figure out where to insert this keyframe.\n    if (pos && typeof pos !== 'number') {\n      pos = this.labels[pos];\n    }\n    return pos as number;\n  }\n\n  /**\n   * Creates a label for a specific time. Labels can be used to seek to specific\n   * times in an animation and can be used to configure keyframes using the pos\n   * parameter in animate() and set().\n   * @param name\n   * @param time\n   * @public\n   */\n  label(name: string, time?: number): this {\n    this.labels[name] = time === undefined ? this.duration : time;\n    return this;\n  }\n\n  /**\n   * Unregisters an event listener.\n   * @param ev The event to unhandle.\n   * @param f The function to unregister for handling the evenja.\n   * @public\n   */\n  off(ev: ja.AnimationEvent, f: ja.AnimationEventListener): this {\n    const callbacks = this.getEventGroup_(ev);\n    const index = callbacks.indexOf(f);\n    if (index !== -1) {\n      callbacks.splice(index, 1);\n    }\n    return this;\n  }\n\n  /**\n   * Registers an event listener to react on the specified evenja.\n   * @param ev The event to handle.\n   * @param f The function to handle the evenja.\n   * @public\n   */\n  on(ev: ja.AnimationEvent, f: ja.AnimationEventListener): this {\n    const callbacks = this.getEventGroup_(ev);\n    const index = callbacks.indexOf(f);\n    if (index === -1) {\n      callbacks.push(f);\n    }\n    return this;\n  }\n\n  /**\n   * Pauses the animation.\n   * @public\n   */\n  pause(): this {\n    this.playState = PAUSED;\n    this.events.push('pause');\n    return queueTransition(this);\n  }\n\n  /**\n   * Plays the animation.\n   * @public\n   */\n  play(): this {\n    this.playState = RUNNING;\n    this.events.push('play');\n    return queueTransition(this);\n  }\n\n  /**\n   * Seeks to the specified time or label. If a undefined label is provided,\n   * the call to .seek() is ignored.\n   * @param time\n   * @public\n   */\n  seek(time: string | number): this {\n    time = this.getPosition_(time);\n    if (time || time === 0) {\n      this.currentTime = time;\n    }\n    // If this is running, pause; otherwise ensure an update occurs.\n    return this.playState !== RUNNING ? this.pause() : queueTransition(this);\n  }\n\n  /**\n   * Forces an update. This can be used after updating timing or keyframes in\n   * configure() to force an\n   */\n  update(): this {\n    return queueTransition(this);\n  }\n}\n", "import { inOut } from \"./inOut\";\nimport { ja } from \"../types\";\n\nconst TAU = 2 * Math.PI;\n\nexport function elastic(\n  type?: ja.EaseTypes,\n  amplitude?: number,\n  period?: number,\n  bounces?: number\n) {\n  // Add defaults where necessary and convert from string.\n  amplitude = +(amplitude || amplitude === 0 ? amplitude : 1);\n  period = +(period || period === 0 ? period : 0.4);\n  bounces = +(bounces || bounces === 0 ? bounces : 4);\n\n  const s = period / bounces;\n  return inOut(n => {\n    if (n === 0 || n === 1) {\n      return n;\n    }\n    return (\n      -amplitude! *\n      Math.pow(2, 10 * (n - 1)) *\n      Math.sin(((n - 1 - s) * TAU) / period!)\n    );\n  }, type);\n}\n", "import { ja } from \"../types\";\n\nexport function readAttribute(target: HTMLElement, key: string) {\n  return target.getAttribute(key) || \"\";\n}\n\nexport function writeAttribute(\n  target: HTMLElement,\n  key: string,\n  value: ja.AnimationTarget\n) {\n  target.setAttribute(key, value.toString());\n}\n", "import { ja } from \"../types\";\n\nexport function readCssVar(target: HTMLElement, key: string) {\n  return target.style.getPropertyValue(key);\n}\n\nexport function writeCssVar(\n  target: HTMLElement,\n  key: string,\n  value: ja.AnimationTarget\n) {\n  target.style.setProperty(key, value.toString());\n}\n", "import { ja } from \"../types\";\n\nexport function readStyle(target: HTMLElement, key: string) {\n  return target.style[key] || getComputedStyle(target)[key];\n}\nexport function writeStyle(\n  target: HTMLElement,\n  key: string,\n  value: ja.AnimationTarget\n) {\n  target.style[key] = value;\n}\n", "import { ja } from \"../types\";\n\nexport function readProperty(target: HTMLElement, key: string) {\n  return target[key];\n}\nexport function writeProperty(\n  target: HTMLElement,\n  key: string,\n  value: ja.AnimationTarget\n) {\n  target[key] = value;\n}\n", "import { ParserContext, match, SYNTAX, NUMBER, UNIT, FUNCTION } from \"./common\";\n\nimport { NUMBER_REGEX, SYNTAX_REGEX, UNIT_REGEX, STRING_REGEX } from \"./common\";\n\nexport function nextToken(ctx: ParserContext): number | undefined {\n  if (match(ctx, SYNTAX_REGEX)) {\n    return SYNTAX;\n  }\n  if (match(ctx, NUMBER_REGEX)) {\n    return NUMBER;\n  }\n  if (match(ctx, UNIT_REGEX)) {\n    return UNIT;\n  }\n  if (match(ctx, STRING_REGEX)) {\n    return FUNCTION;\n  }\n}\n", "import {\n  clearContext,\n  ParserContext,\n  FUNCTION,\n  UNIT,\n  NUMBER,\n} from '../parsers/common';\nimport { nextToken } from '../parsers/transforms';\nimport { cachefn } from '../services/cachefn';\n\nconst ctxTransform = {} as ParserContext;\n\nfunction negateTransformList(value: string) {\n  clearContext(ctxTransform, value);\n\n  let token: number | undefined;\n  let fn: string | undefined;\n  let termCount = 0;\n  let output = '';\n  while (true) {\n    token = nextToken(ctxTransform);\n    if (!token) {\n      // Exit when there is nothing left to do.\n      break;\n    }\n    if (token === FUNCTION) {\n      // Use functions to start over counting numbers/units.\n      fn = ctxTransform.match.toLowerCase();\n      termCount = 0;\n    }\n    if (token !== UNIT && token !== NUMBER) {\n      // If a number or unit, pass content through.\n      output += ctxTransform.match;\n      continue;\n    }\n\n    if (fn === 'matrix') {\n      // Scale defaults to 1 (position 0 and 3)\n      output += termCount % 3 ? '0' : '1';\n    } else if (fn === 'matrix3d') {\n      // Scale defaults to 1.\n      // Example net-0 3d matrix:\n      // 1 0 0 0\n      // 0 1 0 0\n      // 0 0 1 0\n      // 0 0 0 1\n      output += termCount % 5 ? '0' : '1';\n    } else if (/scale([xyz]|3d)?/i.test(fn!)) {\n      output += '1';\n    } else {\n      output += '0';\n    }\n\n    termCount++;\n  }\n  return output;\n}\n\nconst cachedNegateTransformList = cachefn(negateTransformList);\nexport { cachedNegateTransformList as negateTransformList };\n", "import { ja } from '../types';\nimport { isNumeric } from '../utils/numbers';\nimport { clearContext, NUMBER, UNIT, FUNCTION } from '../parsers/common';\nimport {\n  MixerParserContext,\n  nextToken as nextExp,\n} from '../parsers/expressions';\n\nimport { negateTransformList } from './negateTransformList';\n\nconst UNIT_EXTRACTOR_REGEX = /([a-z%]+)/i;\nconst PATH_REGEX = /^m[\\s,]*-?\\d*\\.?\\d+/i;\nconst TRANSFORM_REGEX =\n  // Match on all transform functions.\n  /(perspective|matrix(3d)?|skew[xy]?|(translate|scale|rotate)([xyz]|3d)?)\\(/i;\n\n/**\n * This mixer attempts to automatically parse CSS expressions from each value\n * and then create an interpolated value from it.\n * @param valueA The left value to mix.\n * @param valueB The right value to mix.\n * @param offset The progression offset to use.\n */\nexport function autoMix(\n  valueA: ja.AnimationValue,\n  valueB: ja.AnimationValue,\n  offset: number\n): ja.AnimationValue {\n  if (isNumeric(valueA) && isNumeric(valueB)) {\n    return mixNumber(+valueA, +valueB, offset);\n  }\n  // If the right is a transform list and the left is not, create net-0\n  // transform list on the left that mirrors the right. This allows for tweening\n  // values like none or empty string for the initial keyframe.\n  if (\n    TRANSFORM_REGEX.test(valueB.toString()) &&\n    !TRANSFORM_REGEX.test(valueA.toString())\n  ) {\n    valueA = negateTransformList(valueB.toString());\n  }\n  // If value A or B is null or undefined, swap to empty string.\n  if (valueA == null) {\n    valueA = '';\n  }\n  if (valueB == null) {\n    valueB = '';\n  }\n  return mix(valueA.toString(), valueB.toString(), offset);\n}\n\nconst ctxLeft = {} as MixerParserContext;\nconst ctxRight = {} as MixerParserContext;\n\n/**\n * Mixes a css or path expression.\n * @param {string} left\n * @param {string} right\n * @param {number} progress\n */\nfunction mix(left: string, right: string, progress: number): string {\n  // Reuse contexts to process this request.\n  clearContext(ctxLeft, left);\n  clearContext(ctxRight, right);\n\n  // Identify if these are paths.\n  ctxLeft.isPath = PATH_REGEX.test(left);\n  ctxRight.isPath = PATH_REGEX.test(right);\n\n  let output = '';\n  let rgbChannelsRemaining = 0;\n  let tokenLeft: number | undefined;\n  let tokenRight: number | undefined;\n\n  while (true) {\n    tokenLeft = nextExp(ctxLeft);\n    tokenRight = nextExp(ctxRight);\n    if (!tokenLeft || !tokenRight) {\n      break;\n    }\n    const termLeft = ctxLeft.match;\n    const termRight = ctxRight.match;\n\n    if (tokenLeft === NUMBER && tokenRight === NUMBER) {\n      let numericTerm: number;\n      if (rgbChannelsRemaining) {\n        numericTerm = mixRgbChannel(+termLeft, +termRight, progress);\n        rgbChannelsRemaining--;\n      } else {\n        numericTerm = mixNumber(+termLeft, +termRight, progress);\n      }\n      output += numericTerm;\n    } else if (tokenLeft === UNIT || tokenRight === UNIT) {\n      const unitMatch = UNIT_EXTRACTOR_REGEX.exec(\n        tokenLeft === UNIT ? termLeft : termRight\n      )!;\n      const unit = unitMatch[1];\n      const isWholeNumber = unit === 'px';\n      const unitLeft = parseFloat(termLeft);\n      const unitRight = parseFloat(termRight);\n\n      const numericTerm = mixNumber(\n        unitLeft,\n        unitRight,\n        progress,\n        isWholeNumber\n      );\n\n      // The parseFloat should remove px & % automatically\n      output += numericTerm + unit;\n    } else {\n      const term = progress < 0.5 ? termLeft : termRight;\n      const isRgbFunction =\n        tokenLeft === FUNCTION &&\n        tokenRight === FUNCTION &&\n        (term === 'rgb' || term === 'rgba');\n      if (isRgbFunction) {\n        rgbChannelsRemaining = 3;\n      }\n\n      output += term;\n    }\n  }\n\n  return output;\n}\n\n/**\n * Mixes two numeric terms.\n * @param left The left side of the mix operation.\n * @param right The right side of the mix operation.\n * @param progress The progression between left and right.\n * @param precision The precision expressed a multiple of 10. Ex: 3 precision\n *    would be 100.\n */\nfunction mixNumber(\n  left: number,\n  right: number,\n  progress: number,\n  isWholeNumber?: boolean\n) {\n  const n = left + (right - left) * progress;\n  return isWholeNumber ? Math.round(n) : n;\n}\n\n/**\n * Mixes two RGB channels. In order to match CSS color interpolation, the terms\n * need to first be squared, then multiplied by the progress, then finally,\n * unsquared.\n * @param left The left side of the mix operation.\n * @param right The right side of the mix operation.\n * @param progress The progression between left and right.\n */\nfunction mixRgbChannel(left: number, right: number, progress: number): number {\n  return Math.round(\n    Math.sqrt(\n      Math.min(Math.max(0, (left * left + right * right) * progress), 255 * 255)\n    )\n  );\n}\n", "import { ja } from \"../types\";\nimport { readAttribute, writeAttribute } from \"./attribute\";\nimport { readCssVar, writeCssVar } from \"./cssvar\";\nimport { readStyle, writeStyle } from \"./style\";\nimport { readProperty, writeProperty } from \"./property\";\nimport { autoMix } from \"./mix\";\n\nexport interface TargetMixer {\n  (\n    left: ja.AnimationValue,\n    right: ja.AnimationValue,\n    offset: number\n  ): ja.AnimationValue;\n}\n\nexport interface TargetReader {\n  (target: {}, key: string): ja.AnimationValue;\n}\n\nexport interface TargetWriter {\n  (target: {}, key: string, value: ja.AnimationValue): void;\n}\n\nexport type TargetType =\n  | typeof PROPERTY\n  | typeof CSS_VAR\n  | typeof ATTRIBUTE\n  | typeof STYLE;\n\nexport const PROPERTY = 0,\n  CSS_VAR = 1,\n  ATTRIBUTE = 2,\n  STYLE = 3;\n\nconst htmlAttributeOnly = [\"viewBox\"];\nconst htmlPropOnly = [\"innerHTML\", \"textContent\"];\n\nexport function detectTargetType(\n  target: ja.AnimationTarget,\n  propertyName: string\n): TargetType {\n  const isProbablyHTMLElement =\n    typeof (target as HTMLElement).tagName === \"string\" &&\n    (target as HTMLElement).style;\n\n  if (!isProbablyHTMLElement) {\n    return PROPERTY;\n  }\n\n  if (propertyName.indexOf(\"--\") === 0) {\n    return CSS_VAR;\n  }\n  if (htmlAttributeOnly.indexOf(propertyName) !== -1) {\n    return ATTRIBUTE;\n  }\n  if (htmlPropOnly.indexOf(propertyName) !== -1) {\n    return PROPERTY;\n  }\n  return STYLE;\n}\n\n/**\n * Returns a reader for the given targetType.\n */\nexport function getReader(targetType: TargetType): TargetReader {\n  if (targetType === ATTRIBUTE) {\n    return readAttribute;\n  }\n  if (targetType === CSS_VAR) {\n    return readCssVar;\n  }\n  if (targetType === STYLE) {\n    return readStyle;\n  }\n  return readProperty;\n}\n\n/**\n * Returns a writer for the given targetType.\n */\nexport function getWriter(targetType: TargetType): TargetWriter {\n  if (targetType === ATTRIBUTE) {\n    return writeAttribute;\n  }\n  if (targetType === CSS_VAR) {\n    return writeCssVar;\n  }\n  if (targetType === STYLE) {\n    return writeStyle;\n  }\n  return writeProperty;\n}\n\n/**\n * Returns a mixers for the given targetType.\n */\nexport function getMixer(_targetType: TargetType): TargetMixer {\n  return autoMix;\n}\n", "import { ja } from \"../types\";\n\nconst CACHE = \"__just_cache\";\n\n/**\n * Clear the cache for the target and id.\n * @param id\n * @param target\n */\nexport function clearKeys(id: string, target: ja.AnimationTarget) {\n  if (target[CACHE] && target[CACHE][id]) {\n    delete target[CACHE][id];\n  }\n}\n\n/**\n * Retrieve value against the id, target, and value.\n * @param id\n * @param target\n * @param key\n */\nexport function retrieveValue(\n  id: string,\n  target: ja.AnimationTarget,\n  key: string\n): ja.AnimationValue | undefined {\n  if (target[CACHE] && target[CACHE][id]) {\n    return target[CACHE][id][key];\n  }\n}\n\n/**\n * Store the value against the id, target, and propname.\n * @param id\n * @param target\n * @param key\n * @param value\n */\nexport function storeValue(\n  id: string,\n  target: ja.AnimationTarget,\n  key: string,\n  value: ja.AnimationValue\n) {\n  if (!target[CACHE]) {\n    target[CACHE] = {};\n  }\n  if (!target[CACHE][id]) {\n    target[CACHE][id] = {};\n  }\n  target[CACHE][id][key] = value;\n}\n", "import { ja } from '../types';\n\n/**\n * Resolves a selector or an at-target.\n * @param config The timeline configuration.\n * @param target The target to resolve.\n */\nexport function resolveTargets(\n  config: ja.TimelineConfig,\n  target: string\n): Array<{}> {\n  if (!target) {\n    return [];\n  }\n  if (target.indexOf('@') !== 0) {\n    // TODO:(add component scoping here)\n    // If it isn't a reference, use it as a selector and make that into an [].\n    return Array.prototype.slice.call(document.querySelectorAll(target));\n  }\n  // Get the target if it exists\n  const maybeTarget = config.targets[target];\n  if (!maybeTarget) {\n    throw Error('Target ' + target + ' not configured.');\n  }\n  // If the target is an array, just return it.\n  if (typeof (maybeTarget as []).length === 'number') {\n    return maybeTarget as Array<{}>;\n  }\n  // If the target is not an array, wrap it.\n  return [maybeTarget];\n}\n", "import { byNumber, clamp, toNumber, findUpperIndex } from '../utils/numbers';\nimport { detectTargetType, getReader, getWriter, getMixer } from '../adapters';\nimport { retrieveValue, storeValue, clearKeys } from '../services/valuecache';\nimport { getEase, eases } from '../eases/eases';\nimport { resolveTargets } from '../services/targets';\nimport { ja } from '../types';\nimport { IDLE } from '../utils/playStates';\n\n/**\n * Renders the current state of the dopesheet.\n * @param config The configuration to read.\n */\nexport function renderTween(\n  config: ja.TimelineConfig,\n  operations: Array<() => void>\n) {\n  const { currentTime, playState, id } = config;\n  const localTime = currentTime % config.duration;\n  for (const targetName in config.keyframes) {\n    const keyframes = config.keyframes[targetName];\n    const targets = resolveTargets(config, targetName);\n    for (const propName in keyframes) {\n      const property = keyframes[propName];\n      const times = getTimes(property);\n      const total = targets.length;\n      for (let index = 0; index < total; index++) {\n        const target = targets[index];\n        // Unpack these immediately because the return object is shared.\n        const targetType = detectTargetType(target, propName);\n        const write = getWriter(targetType);\n        if (playState !== IDLE) {\n          const read = getReader(targetType);\n          const mix = getMixer(targetType);\n          const currentValue = read(target, propName);\n          const maybeUpperIndex = findUpperIndex(times, localTime);\n          const upperIndex = clamp(maybeUpperIndex, 0, times.length - 1);\n          // If the last frame is out of range, use the last frame for both\n          // upper and lower indexes.\n          const lowerIndex =\n            upperIndex !== maybeUpperIndex ? upperIndex : upperIndex - 1;\n          const lowerTime = lowerIndex < 0 ? 0 : times[lowerIndex];\n          const upperTime = times[upperIndex];\n          const upperProp = property[upperTime];\n\n          const upperValue = upperProp.value;\n          const upperEase = getEase(upperProp.$ease || '');\n          const lowerFrame = property[times[lowerIndex]];\n\n          // Attempt to load initial value from cache or add the current as init\n          let lowerValue: ja.AnimationValue;\n\n          if (lowerIndex < 0 || !lowerFrame) {\n            let initialValue = retrieveValue(id, target, propName);\n            if (initialValue == null) {\n              initialValue = currentValue;\n              storeValue(id, target, propName, currentValue);\n            }\n            lowerValue = initialValue;\n          } else {\n            lowerValue = lowerFrame.value;\n          }\n\n          // Calculate the offset and apply the easing\n          const offset = upperEase(\n            getOffset(\n              lowerTime,\n              upperTime,\n              localTime,\n              index,\n              total,\n              upperProp.$stagger || 0,\n              upperProp.$delay || 0,\n              upperProp.$endDelay || 0\n            )\n          );\n\n          // Find the next value, but only set it if it differs from the current\n          // value.\n          const value = mix(lowerValue, upperValue, offset);\n          if (currentValue !== value) {\n            // Queue up the rendering of the value.\n            operations.push(() => write(target, propName, value));\n          }\n        } else {\n          const initialValue = retrieveValue(id, target, propName);\n          if (initialValue != null) {\n            write(target, propName, initialValue);\n          }\n        }\n      }\n    }\n\n    // Clear cache for targets that have gone idle.\n    for (const target of targets) {\n      if (playState === IDLE) {\n        clearKeys(id, target);\n      }\n    }\n  }\n}\n\nfunction getOffset(\n  frameLower: number,\n  frameUpper: number,\n  localTime: number,\n  targetIndex: number,\n  targetCount: number,\n  stagger: number,\n  delay: number,\n  endDelay: number\n): number {\n  let lower = frameLower;\n  let upper = frameUpper;\n  if (delay) {\n    lower += delay;\n  }\n  if (endDelay) {\n    upper -= endDelay;\n  }\n  if (stagger) {\n    // Adjust stagger so the front and end are delayed equal to the stagger.\n    const staggerDelay = Math.abs((targetIndex + 1) * stagger);\n    const totalDelay = Math.abs(targetCount * stagger);\n    lower += staggerDelay;\n    upper -= totalDelay - staggerDelay;\n  }\n  if (localTime <= lower) {\n    // Safeguard against offsets less than 0.\n    return 0;\n  }\n  if (localTime >= upper) {\n    // Safeguard against offsets greater than 1.\n    return 1;\n  }\n  return (localTime - lower) / (upper - lower);\n}\n\n/**\n * Gets all of the times in the property in order.\n * @param property The property from which to extract times.\n */\nfunction getTimes(property: Record<string, ja.Keyframe>) {\n  return Object.keys(property).map(toNumber).sort(byNumber);\n}\n", "import { ja } from '../types';\n\nexport function renderSubtimeline(\n  config: ja.TimelineConfig,\n  operations: Array<() => void>\n) {}\n", "import { Timeline } from './timeline';\nimport { resolveTargets } from '../services/targets';\nimport { ja } from '../types';\n\n/**\n * Configure a tween from the (current) position for the duration specified.\n * @param targets The element, object, or selector to animate.\n * @param duration The duration in milliseconds of the tween.\n * @param props The end state properties of the tween.\n * if not specified.\n * @public\n */\nfunction animate<T>(\n  this: Timeline,\n  targets: T | string,\n  duration: number,\n  props: Partial<ja.KeyframeProps>\n): Timeline {\n  let pos = this.getPosition_(props.$from);\n  if (pos == null) {\n    pos = this.duration;\n  }\n\n  /* If the target is not a string, create an alias so the keyframe can be\n   * stored separatedly from the objects themselves. */\n  if (typeof targets !== 'string') {\n    let targetId = findTarget(this.targets, targets);\n    if (!targetId) {\n      if (!this.targetIds) {\n        this.targetIds = 0;\n      }\n      targetId = '@_object_' + ++this.targetIds;\n      this.target(targetId, targets);\n    }\n    targets = targetId;\n  }\n\n  if (props.$delay) {\n    duration += props.$delay;\n  }\n  if (props.$endDelay) {\n    duration += props.$endDelay;\n  }\n  if (props.$stagger) {\n    // Extend the duration to fit staggering in all of the targets.\n    duration += resolveTargets(this, targets).length * props.$stagger;\n  }\n\n  let targetProps = this.keyframes[targets];\n  if (!targetProps) {\n    targetProps = this.keyframes[targets] = {};\n  }\n\n  for (const prop in props) {\n    const value = props[prop];\n    // Handle all properties (not $ease, etc.)\n    if (prop[0] !== '$' && (value || value === 0)) {\n      // Get or create a property to hold this keyframe.\n      let propKeyframes = targetProps[prop];\n      if (!propKeyframes) {\n        propKeyframes = targetProps[prop] = {};\n      }\n      // Copy options to individual keyframe. ($ease, etc.)\n      const keyframe = { value } as ja.Keyframe;\n      for (const option in props) {\n        if (option[0] === '$' && props[option]) {\n          keyframe[option] = props[option];\n        }\n      }\n      propKeyframes[pos + duration] = keyframe;\n    }\n  }\n\n  return this.update();\n}\n\n/**\n * Adds a delay at the current position.\n * @param duration the amount to delay.\n * @public\n */\nfunction delay(this: Timeline, duration: number): Timeline {\n  return this.animate('', duration, { '': 0 });\n}\n\n/**\n * Sets the properties at a given time. This is a convenience method for\n * calling animate with an ease of steps(1, end).\n * @public\n */\nfunction set<T>(\n  this: Timeline,\n  targets: T | string,\n  props: ja.KeyframeProps\n): Timeline {\n  props.$ease = 'steps(1,end)';\n  return this.animate(targets, 0, props);\n}\n\n/**\n * Creates a target alias that can be referred to in the targets parameter in\n * animate() and set().  It is recommended to prefix the alias with @ to\n * prevent conflicts with CSS selectors. This is useful for creating generic\n * animations where the target is not known when defining the tweens.\n * @param alias\n * @param target\n * @public\n */\nfunction target(\n  this: Timeline,\n  alias: string,\n  target: ja.AnimationTarget\n): Timeline {\n  if (!this.targets) {\n    this.targets = {};\n  }\n  this.targets[alias] = target;\n  // If targets change, ensure update in case a target has been replaced.\n  return this.update();\n}\n\nfunction findTarget(\n  targets: Record<string, ja.AnimationTarget>,\n  target: ja.AnimationTarget\n): string | undefined {\n  if (targets) {\n    for (const targetid in targets) {\n      if (target === targets[targetid]) {\n        return targetid;\n      }\n    }\n  }\n}\n\nTimeline.prototype.animate = animate;\nTimeline.prototype.delay = delay;\nTimeline.prototype.set = set;\nTimeline.prototype.target = target;\n\ndeclare module './timeline' {\n  interface Timeline {\n    animate: typeof animate;\n    delay: typeof delay;\n    set: typeof set;\n    target: typeof target;\n    targetIds: number;\n    targets: Record<string, ja.AnimationTarget>;\n  }\n}\n", "import { back } from './eases/back';\nimport { bounce } from './eases/bounce';\nimport { cubicBezier } from './eases/cubicBezier';\nimport { yoyo } from './eases/yoyo';\nimport { repeat } from './eases/repeat';\nimport { getEase, eases } from './eases/eases';\nimport { ja } from './types';\nimport { nextAnimationFrame, tick } from './services/tick';\nimport { power } from './eases/power';\nimport { sine } from './eases/sine';\nimport { steps } from './eases/steps';\nimport { Timeline } from './components/timeline';\nimport { elastic } from './eases/elastic';\nimport { renderers } from './services/animator';\nimport { renderTween } from './renderers/renderTween';\nimport { renderSubtimeline } from './renderers/renderSubtimeline';\n\n// Register second half of Timeline\nimport './components/timeline.animate';\n\n// Register built-in easings\n// Linear is the fallback when an easing isn't found, so we won't register it.\neases.back = back;\neases.bounce = bounce;\neases['cubic-bezier'] = cubicBezier;\neases.elastic = elastic;\neases.power = power;\neases.repeat = repeat;\neases.sine = sine;\neases.steps = steps;\neases.yoyo = yoyo;\n\n// Register timeline renderers.\nrenderers.push(renderSubtimeline);\nrenderers.push(renderTween);\n\n/**\n * Convenience method for doing animations.\n */\nfunction animate<T>(\n  targets: T | string,\n  duration: number,\n  props: Partial<ja.KeyframeProps>\n) {\n  return new Timeline().animate(targets, duration, props);\n}\n\n// Export out globals.\nexport const just = {\n  animate,\n  eases,\n  getEase,\n  nextAnimationFrame,\n  Timeline,\n  tick,\n};\n"],
  "mappings": "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",
  "names": ["inOut", "ease", "type", "o", "factor", "back", "type", "inOut", "n", "mirror", "ease", "n", "bounce", "type", "factor", "inOut", "mirror", "o", "linear", "o", "MAX_ITERATIONS", "bezier", "c1", "c2", "t", "it", "cubicBezier", "cx1", "cy1", "cx2", "cy2", "linear", "min", "max", "iterations", "mid", "tPos", "yoyo", "times", "o", "floor", "repeat", "times", "o", "SYNTAX_REGEX", "PAREN_OPEN_REGEX", "PAREN_CLOSE_REGEX", "HEX_REGEX", "STRING_REGEX", "NUMBER_REGEX", "UNIT_REGEX", "PATH_COMMAND_REGEX", "clearContext", "ctx", "value", "match", "regex", "cachefn", "fn", "cache", "rank", "str", "cachedValue", "rankIndex", "hexToRgb", "hex", "h", "g", "b", "cachedHexToRgb", "cachefn", "nextToken", "ctx", "match", "PAREN_CLOSE_REGEX", "PAREN_OPEN_REGEX", "SYNTAX_REGEX", "PATH_COMMAND_REGEX", "STRING_REGEX", "searchString", "endOfString", "terms", "UNIT_REGEX", "NUMBER_REGEX", "HEX_REGEX", "hexValue", "cachedHexToRgb", "eases", "easeCtx", "getEase", "easeString", "clearContext", "token", "fn", "linear", "waitingForTerms", "fnName", "terms", "nextToken", "composeEase", "factoryName", "args", "easeFactory", "outerFn", "o", "cachedGetEases", "cachefn", "tasks", "nextAnimationFrame", "updateAll", "tick", "task", "tasks", "i", "power", "type", "c", "inOut", "o", "sine", "type", "inOut", "o", "steps", "count", "type", "fn", "x", "n", "byNumber", "a", "b", "clamp", "value", "min", "max", "findUpperIndex", "list", "i", "isNumeric", "obj", "toNumber", "str", "IDLE", "PAUSED", "RUNNING", "FINISH", "CANCEL", "FRAME_SIZE", "queue", "lastTime", "renderers", "queueTransition", "configurator", "tick", "processTimelines", "time", "delta", "clamp", "configs", "config", "detectPlayStateChanges", "updateTiming", "CANCEL", "IDLE", "FINISH", "PAUSED", "listenersToCall", "event", "listeners", "operations", "renderer", "i", "RUNNING", "operation", "listener", "isBackwards", "activeDuration", "autoNumber", "Timeline", "_Timeline", "duration", "targetName", "target", "propName", "time", "options", "self", "RUNNING", "CANCEL", "queueTransition", "json", "k", "FINISH", "memento", "key", "val", "ev", "eventGroup", "pos", "name", "f", "callbacks", "index", "PAUSED", "TAU", "elastic", "type", "amplitude", "period", "bounces", "s", "inOut", "readAttribute", "target", "key", "writeAttribute", "value", "readCssVar", "target", "key", "writeCssVar", "value", "readStyle", "target", "key", "writeStyle", "value", "readProperty", "target", "key", "writeProperty", "value", "nextToken", "ctx", "match", "SYNTAX_REGEX", "NUMBER_REGEX", "UNIT_REGEX", "STRING_REGEX", "ctxTransform", "negateTransformList", "value", "clearContext", "token", "fn", "termCount", "output", "nextToken", "cachedNegateTransformList", "cachefn", "UNIT_EXTRACTOR_REGEX", "PATH_REGEX", "TRANSFORM_REGEX", "autoMix", "valueA", "valueB", "offset", "isNumeric", "mixNumber", "cachedNegateTransformList", "mix", "ctxLeft", "ctxRight", "left", "right", "progress", "clearContext", "output", "rgbChannelsRemaining", "tokenLeft", "tokenRight", "nextToken", "termLeft", "termRight", "numericTerm", "mixRgbChannel", "unit", "isWholeNumber", "unitLeft", "unitRight", "term", "n", "PROPERTY", "CSS_VAR", "ATTRIBUTE", "STYLE", "htmlAttributeOnly", "htmlPropOnly", "detectTargetType", "target", "propertyName", "getReader", "targetType", "readAttribute", "readCssVar", "readStyle", "readProperty", "getWriter", "writeAttribute", "writeCssVar", "writeStyle", "writeProperty", "getMixer", "_targetType", "autoMix", "CACHE", "clearKeys", "id", "target", "retrieveValue", "key", "storeValue", "value", "resolveTargets", "config", "target", "maybeTarget", "renderTween", "config", "operations", "currentTime", "playState", "id", "localTime", "targetName", "keyframes", "targets", "resolveTargets", "propName", "property", "times", "getTimes", "total", "index", "target", "targetType", "detectTargetType", "write", "getWriter", "IDLE", "read", "getReader", "mix", "getMixer", "currentValue", "maybeUpperIndex", "findUpperIndex", "upperIndex", "clamp", "lowerIndex", "lowerTime", "upperTime", "upperProp", "upperValue", "upperEase", "cachedGetEases", "lowerFrame", "lowerValue", "initialValue", "retrieveValue", "storeValue", "offset", "getOffset", "value", "clearKeys", "frameLower", "frameUpper", "targetIndex", "targetCount", "stagger", "delay", "endDelay", "lower", "upper", "staggerDelay", "totalDelay", "toNumber", "byNumber", "renderSubtimeline", "config", "operations", "animate", "targets", "duration", "props", "pos", "targetId", "findTarget", "resolveTargets", "targetProps", "prop", "value", "propKeyframes", "keyframe", "option", "delay", "set", "target", "alias", "targetid", "Timeline", "eases", "back", "bounce", "cubicBezier", "elastic", "power", "repeat", "sine", "steps", "yoyo", "renderers", "renderSubtimeline", "renderTween", "animate", "targets", "duration", "props", "Timeline", "just", "cachedGetEases", "nextAnimationFrame", "tick"]
}
